import * as snarkjs from "snarkjs";
import * as fs from "fs";
import * as path from "path";
import { buildMimcSponge } from "circomlibjs";
import { createHash } from "crypto";
import { MASTER_PASSWORD } from "./password";

const circuitsPath = "./circuits";
const hashCircuitPath = path.join(circuitsPath, "hash.wasm");
const hashZkeyPath = path.join(circuitsPath, "hash.zkey");
const vKeyPath = path.join(circuitsPath, "hash.vkey.json");

/**
 * This interface represents the full set of values that represent a
 * proof of knowledge of the master password.
 */
export interface FullProof {
  proof: any;
  publicSignals: any;
}

/**
 * There is no notion of strings in circom. Thus, in order to pass a string
 * into the circuit, we hash it using sha256, which lets us pass a representation
 * of the password into the circuit.
 *
 * There are other ways to pass strings into circuits. For example, we could have
 * passed an array of 'bytes' as signals into the circuit. A disadvantage of that
 * approach would be that it would require circuit changes to support passwords of different sizes.
 */
export function convertPasswordToUint256(password: string): BigInt {
  const digest = "0x" + createHash("sha256").update(password).digest("hex");
  return BigInt(digest);
}

/**
 * Given a string password, generates a proof of knowledge of that password.
 * In practice, the proof actually proves the following statement:
 *
 * "I know the string which when passed into the function f(x) = mimc(sha256(x))
 * results in the value Y."
 */
export async function generateProofOfPasswordKnowledge(
  password: string
): Promise<FullProof> {
  const input = {
    x: convertPasswordToUint256(password).toString(),
  };

  const { proof, publicSignals } = await snarkjs.groth16.fullProve(
    input,
    hashCircuitPath,
    hashZkeyPath
  );
  return { proof, publicSignals };
}

/**
 * Given a proof generated by {@link generateProofOfPasswordKnowledge}, verifies that
 * 1. the ZKP is valid
 * 2. the password which the user is claiming to know matches the {@link MASTER_PASSWORD}.
 */
export async function verifyPasswordKnowledge(
  fullProof: FullProof
): Promise<boolean> {
  const mimc = await buildMimcSponge();
  const mimcKey = 0;
  const mimcNumOutputs = 1;
  const input = {
    x: convertPasswordToUint256(MASTER_PASSWORD).toString(),
  };
  const mimcResult = mimc.multiHash([input.x], mimcKey, mimcNumOutputs);
  const expectedOutput = { out: mimc.F.toObject(mimcResult) };
  const vKey = JSON.parse(fs.readFileSync(vKeyPath).toString());

  const proofVerified = await snarkjs.groth16.verify(
    vKey,
    fullProof.publicSignals,
    fullProof.proof
  );
  const hashMatches =
    expectedOutput.out.toString() === fullProof.publicSignals[0];

  if (proofVerified === true) {
    console.log("[Proving] SNARK verified");
  } else {
    console.log("[Proving] SNARK not verified");
    return false;
  }

  if (hashMatches) {
    console.log("[Proving] password hash matches");
  } else {
    console.log("[Proving] password hash does not match");
    return false;
  }

  return true;
}
